\chapter{Firefox Sync Architecture}
\label{chapter:firefox-sync-architecture}

As mentioned in the previous chapters, the synchronization support is implemented in Epiphany with the help of Firefox Sync. Therefore, to better understand how the synchronization works in Epiphany, this chapter delves into the architectures of Firefox Sync, describing its key entities and how the synchronization client interacts with them.

\textit{Disclaimer: Everything that is described further is presented strictly from the point of view of Epiphany's Firefox Sync support. Nothing extra is added, nothing less is omitted.}

The architecture of Firefox Sync is somewhat complex but nonetheless interesting. A high-level overview of the basic functionalities is illustrated in \labelindexref{Figure}{img:fx-sync-overview}.

\fig[scale=0.6]{src/img/04FirefoxSyncOverview.pdf}{img:fx-sync-overview}{Firefox Sync Overview}

As you can notice, there are three servers with whom any synchronization client needs to interact: the Firefox Accounts Server, the Token Server and the Sync Storage Server. Each of them has a well-determined role and its own set of rules to which any synchronization client needs to obey.

\section{Prerequisites}
\label{sec:prerequisites}

Before I proceed to describe each of the servers that compound Firefox Sync, there are a few concepts that need to be explained first. These are essentially schemes and cryptographic algorithms that each synchronization client needs to use to be able to communicate with the servers.

\subsection{Hawk Authentication Scheme}
\label{sub-sec:hawk}

\begin{quote}
"Hawk is an HTTP authentication scheme providing mechanisms for making authenticated HTTP requests with partial cryptographic verification of the request and response, covering the HTTP method, request URI (Uniform Resource Identifier), host, and optionally the request payload. Hawk uses a set of client credentials which include an identifier (e.g. username) and key (e.g. password). The key is never included in authenticated requests. Instead, it is used to calculate a request MAC (Message Authentication Code) value which is included in its place. Hawk uses a nonce to limit the possibility of replay attacks, which is generated by the client and used in combination with a timestamp, thus leading to less interaction with the server. Hawk scheme is not intended to protect the key itself because the client and server must both have access to the key material in the clear.

The primary design goals of this scheme are to:
\begin{itemize}
  \item Simplify and improve HTTP authentication for services that are unwilling or unable to deploy TLS (Transport Layer Security) for all resources.

  \item Secure credentials against leakage (e.g., when the client uses some form of dynamic configuration to determine where to send an authenticated request).

  \item Avoid the exposure of credentials sent to a malicious server over an unauthenticated secure channel due to client failure to validate the server's identity as part of its TLS handshake." \cite{hawk-scheme}
\end{itemize}
\end{quote}

As stated by Hawk's author, the main purpose of this authentication scheme is not only to simplify and improve HTTP authentication but also to secure and protect the credentials. For this reason, many endpoints of the Firefox Sync servers enforce the requests to be authenticated with Hawk.

Every client request that is Hawk-authenticated has the Authorization HTTP header set to a MAC value and some additional metadata. Likewise, every server response to Hawk-authenticated requests contains a Server-Authorization HTTP header that authenticates the response so that the client can rest assured it originates from the right server. Clients need to obtain a token id and a token key from the server to sign the requests\footnote{\url{https://blog.mozilla.org/services/2015/02/05/whats-hawk-and-how-to-use-it/}}.

\subsection{HMAC-Based Extract-and-Expand Key Derivation Function}
\label{sub-sec:hkdf}

HKDF is a type of KDF (Key Derivation Function) designed to generate a strong cryptographic material from an initial keying material and can be used as a building block in various protocol and applications. HKDF follows the \textit{extract-then-expand} paradigm, where the KDF logically consists of two modules. The first phase takes the input keying material and extracts from it a fixed-length pseudorandom key, while the second phase iteratively expands the previously extracted key into several additional pseudorandom keys which form the output of the KDF \cite{krawczyk2010hmac}.

The number of iterations depends on the desired output length and the length of the hash function used. To obtain an output of length N, one has to select the first N bytes from the concatenated pseudorandom keys. As its name suggests, the hash function that is used is HMAC (Hash-based Message Authentication Code).

One may argue that HKDF is not the fastest way to generate ciphertexts. However, it is safe and easy to specify and implement. Firefox Sync uses HKDF-based ciphers to protect the content of the requests sent to the servers. HKDF is used to create a number of random bytes equal to the length of the message. After that, the random bytes are XORed with the cleartext to produce the ciphertext and an HMAC is computed from the ciphertext to protect the integrity of the message \cite{onepw-protocol}.

\subsection{Password-Based Key Derivation Function 2}
\label{sub-sec:pbkdf2}

PBKDF2 is also a KDF not very different from HKDF. It is designed to derive a cryptographic key that can be further used in subsequent operations from an input passphrase (i.e. a password) and a salt value. This process is commonly referred as \textit{key stretching}. Like HKDF, it works iteratively, but, unlike HKDF, the number of iterations is set by the user and not internally decided. The number of iterations is considered a trade-off between better protection against password cracking and less computational time.

PBKDF2 applies a pseudorandom function to derive keys. The length of the derived key is essentially unbounded. However, the maximum effective search space for the derived key may be limited by the structure of the underlying pseudorandom function. PBKDF2 is recommended for new applications \cite{kaliski2000pkcs}.

Firefox Sync relies on PBKDF2 to stretch the user password (using the email address as salt) into a \textit{quickly stretched password token} (a.k.a. \textit{quickStretchedPW}) when creating a new account or signing in with an existing account.

\section{Firefox Accounts Server}
\label{sec:firefox-accounts-server}

The Firefox Accounts Server is an HTTP server that manages all the operations related to a Firefox account, providing an endpoint for each one. Clients can use its API to create and delete Firefox accounts, sign in with existing accounts, change the account password, handle forgotten passwords, obtain signed identity certificates, etc. Most of its endpoints enforce Hawk-authenticated requests.

In the context of Firefox Sync, the Firefox Accounts Server plays several important roles:
\begin{enumerate}
  \item It initiates a session by delivering a \textit{session token} (further called \textit{sessionToken}) to the client upon sign in.

  \item It delivers a bundle of tokens that are further used by the client to derive the account's master key that grants access to the synchronized records on the storage server. This key is called the \textit{Sync Key} and is a 32-bytes token which is permanently generated when the Firefox account is created. Therefore, it should be considered secret and not ever be displayed in plain text as it could lead to the user data on the storage server being compromised.

  \item Based on the \textit{sessionToken}, it delivers signed identity certificates that are used by the client to create BrowserID\footnote{\url{https://github.com/mozilla/id-specs/blob/prod/browserid/index.md}} assertions. These are further used to obtain the storage endpoint and the storage credentials from the Token Server, as shown in \labelindexref{Figure}{img:fx-sync-overview}.

  \item When requested by the client, it terminates the session and invalidates the previously delivered \textit{sessionToken}. This is usually associated with the action of signing out.
\end{enumerate}

Each of the activities enumerated above has a particular endpoint assigned on the Firefox Accounts Server, which I will be describing next.

\subsection{Account Login Endpoint}
\label{sub-sec:account-login-endpoint}

{\tt POST /account/login?keys=true}. This is the endpoint which handles the sign in and is responsible for delivering the \textit{sessionToken} together with other significant tokens (which I will be presenting shortly). The actions that the client has to perform when sending a request to this endpoint are illustrated in \labelindexref{Figure}{img:fxa-login} and described next.

\fig[scale=0.6]{src/img/04FxALogin.pdf}{img:fxa-login}{Signing In to the Firefox Accounts Server}

The client feeds the user password into exactly 1000 iterations of PBKDF2 using the email address as salt to obtain the \textit{quickStretchedPW} token. This token is further fed into HKDF to obtain the \textit{authPW} token. The user email and the \textit{authPW} are then wrapped up in a JSON string that makes the body of the request sent to the Firefox Account Server. In case of a valid request, the server sends in return a JSON string containing the account identifier (called \textit{uid} - this will be used to verify the identity certificates in the future), a \textit{sessionToken} and a \textit{keyFetchToken} (this will be used to retrieve the \textit{Sync Key} from the next endpoint). All of these are 32-bytes tokens, except for the \textit{uid} which is 16-bytes. Requests sent to this endpoint are not Hawk-authenticated \cite{onepw-protocol}.

\subsection{Account Keys Endpoint}
\label{sub-sec:account-keys-endpoint}

{\tt Hawk GET /account/keys}. This is the endpoint responsible for delivering the account's \textit{Sync Key}. The steps are illustrated in \labelindexref{Figure}{img:fxa-keys} and briefly described next.

\fig[scale=0.55]{src/img/04FxAKeys.pdf}{img:fxa-keys}{Getting the Sync Key from the Firefox Accounts Server}

The client uses the previously obtained \textit{keyFetchToken} to derive four other tokens through two HKDF processes. The first HKDF process derives the Hawk id and key (these are 32-bytes tokens which are used to authenticate the request sent to the server) together with a new 32-bytes keying material that serves as input for the second HKDF process. The second HKDF process derives the so-called \textit{respHMACkey} and \textit{respXORkey} tokens. The former is a 32-bytes token, while the latter is a 64-bytes token. In response to the request, the Firefox Accounts Server sends in return a bundle which holds a ciphertext and a pre-calculated HMAC value. The client uses the previously derived \textit{respHMACkey} to compute the HMAC value of the ciphertext and compares it to the HMAC value received from the server. After that, the ciphertext is XORed with the \textit{respXORkey} to obtain a 64-bytes token of which the first 32 bytes represent \textit{kA} and are left unused. The last 32 bytes are XORed with the \textit{unwrapBKey} token to obtain \textit{kB} which represents the account's \textit{Sync Key}. \textit{unwrapBKey} is yet another 32-bytes token which can be obtained at sign in or can be derived from the \textit{quickStretchedPW} token using HKDF. The hashing algorithm used in HMAC is SHA-256 (Secure Hash Algorithm) \cite{onepw-protocol}.

\subsection{Sign Certificate Endpoint}
\label{sub-sec:sign-certificate-endpoint}

{\tt Hawk POST /certificate/sign}. This is the endpoint which handles the delivery of signed identity certificates. The process of obtaining a certificate from the server is illustrated in \labelindexref{Figure}{img:fxa-certificate} and is described next.

\fig[scale=0.6]{src/img/04FxACertificate.pdf}{img:fxa-certificate}{Getting a Signed Certificate from the Firefox Accounts Server}

The client feeds the previously obtained \textit{sessionToken} into HKDF to derive a Hawk id and key that will be used to authenticate the request sent to the server. The body of the request consists of a JSON string containing the desired duration of the certificate (limited to 24 hours) together with the public key of an RSA (Rivest-Shamir-Adelman) key pair generated by the client. In response to the request, the server sends in return an identity certificate signed with the given public RSA key. The client will further use the obtained certificate to produce signed BrowserID assertions for delivery to relying parties, such as the Token Server \cite{onepw-protocol}.

\subsection{Session Destroy Endpoint}
\label{sub-sec:session-destroy-endpoint}

{\tt Hawk POST /session/destroy}. This is the endpoint that handles the termination of a session. The client sends a request to this endpoint when it wishes to destroy a session (usually when the user signs out). The Hawk id and key required to authenticate the request are derived from the \textit{sessionToken} via HKDF. The request of the body is nothing but an empty JSON string. In case of a valid request, the Firefox Accounts server destroys the current session and invalidates the \textit{sessionToken}. To obtain a new \textit{sessionToken}, the client needs to send a new request to the {\tt/account/login} endpoint \cite{fxa-server-docs}.

\section{Token Server}
\label{sec:token-server}

By design, the Token Server plays an important role, by providing a centralized login service for other applications \cite{token-server-docs}. In the context of Firefox Sync, the role of the Token Server is strictly limited to providing the endpoint of the storage server assigned to the user together with a pair of credentials (an id and a key) that grants access to the storage server. The synchronization client will further use these credentials to Hawk-authenticate the requests sent to the storage server. The process of obtaining the storage endpoint and credentials from the Token Server is illustrated in \labelindexref{Figure}{img:token-server-flow} and described next.

\fig[scale=0.65]{src/img/04TokenServerFlow.pdf}{img:token-server-flow}{Getting the Storage Endpoint and Credentials from the Token Server}

The client uses a previously obtained identity certificate signed by the Firefox Account Server to create a BrowserID assertion from it. The client then puts the BrowserID assertion in the Authorization HTTP header of the request sent to the Token Server. Given a correct assertion, the Token Server responds with the storage endpoint and storage credentials wrapped up into a JSON string. The credentials have a limited duration which is also included in the JSON string. When that duration expires, the client needs to request new credentials.

The process of creating a BrowserID assertion from an identity certificate is not trivial. An assertion consists of an identity certificate and an identity assertion. The former proves that the client owns that identity, while the latter allows websites to confirm that the assertion is intended to them\footnote{\url{https://fuller.li/posts/how-does-browserid-work/}}. In this case, to the Token Server. The identity assertion is signed with the private key of the RSA key pair described in \labelindexref{Subsection}{sub-sec:sign-certificate-endpoint}.

\section{Sync Storage Server}
\label{sec:sync-storage-server}

The Sync Storage Server plays the vital role of storing the actual synchronized data records and also elementary metadata useful to the synchronization clients. It exposes an HTTP interface to access the stored data and it only accepts Hawk-authenticated requests with the pair of id and key obtained from the Token Server. Each Firefox account has a particular node assigned on the Sync Storage Server, which translates to a specific endpoint of the server. The endpoint is also obtained from the Token Server as described in \labelindexref{Section}{sec:token-server}.

It is worth mentioning that the Sync Storage Server only acts as a storage unit and nothing more. It stores the data as is received. That is because the data is collected encrypted from the synchronization clients, so there isn't much that the server can do. Moreover, the server would not ever delete or modify the data on its own. The only ones that can add, modify or delete data are the synchronization clients through the HTTP API of the Sync Storage Server. Therefore, most of the synchronization falls into the responsibility of the clients \cite{sync-client-docs}.

\subsection{Sync Storage API v1.5}
\label{sub-sec:sync-storage-api}

The Sync Storage API has undergone a few changes over time. The current version is 1.5 and has been introduced in Firefox 29 in 2013\footnote{\url{https://wiki.mozilla.org/RapidRelease/Calendar}}. The lowest-level unit of the Sync Storage Server is called BSO (Basic Storage Object) and is nothing more than a JSON wrapper around the item sent to the server.

Each BSO is assigned to a collection with other related BSOs. Collections are created implicitly when a BSO is stored in them for the first time and continue to exist indefinitely until they are explicitly deleted, even if they no longer contain any BSOs \cite{storage-server-docs}. An overview of the collections on the Sync Storage Server is provided in \labelindexref{Subsection}{sub-sec:collections-overview}.

When uploaded to the server, each BSO must follow the same pattern. Namely, the JSON must contain an \textit{id} string member (this is a Base64-encoded string, usually 12 characters long) and a \textit{payload} object member that contains the actual data of the record. When the server receives a BSO, it appends a \textit{modified} integer field that represents the last-modified timestamp of the BSO to facilitate data coordination between multiple clients.

As previously mentioned, the Sync Storage Server provides an HTTP API to access the stored records. The API allows the synchronization clients to interact both with individual BSOs and with collections as a whole. Endpoints are provided to add new records, to update or delete existing records and also to download a single record or an entire collection. Clients can also query a collection for changes since a given time in the past and obtain only the modified records \cite{storage-server-docs}.

\subsection{Collections Overview}
\label{sub-sec:collections-overview}

As mentioned before, the Sync Storage Server organizes BSOs into collections. The collections provide a logical separation of the records stored on the server and are divided into default collections and additional collections.

The default collections hold BSOs that describe the browsing data under the Firefox object formats \cite{sync-client-docs}. The relevant default collections are:

\begin{itemize}
  \item \textbf{\textit{Bookmarks}}. This collection includes BSOs that represent a bookmarked website in Firefox. A bookmark object is described by a JSON string containing the id, title, URI and tags of the bookmark, amongst others.

  \item \textbf{\textit{History}}. This collection contains BSOs that describe a history record. A history object is represented by a JSON string carrying the id, title and URI of the website visited and the timestamp of the visit.

  \item \textbf{\textit{Passwords}}. This collection holds BSOs that describe a saved password. A password object is represented by a JSON string containing the hostname and the URI of the website where the password is applicable, the names of the username and password form fields and the username and password itself.

  \item \textbf{\textit{Tabs}}. This collection handles the open tabs in the web browsers. Each web browser has only one BSO associated. An object that describes the open tabs is described by a JSON string containing the name of the client supplying the tabs and an array of objects that represent each tab (the title and URI of the page and the favicon URI of the tab).
\end{itemize}

The additional collections hold useful data for the internal management of the clients. They are:

\begin{itemize}
  \item \textbf{\textit{Clients}}. This collection contains information about the synchronization clients which are currently synchronizing and belong to the current Firefox account. Each client has the duty of uploading a BSO with the information describing itself when the user signs in and delete it when the user signs out. A client object is represented by a JSON string containing the id, name, type and operating system of the client, amongst others.

  \item \textbf{\textit{Crypto}}. This collection plays the important role of holding the cryptographic keys that are used to encrypt and decrypt all the other records on the Sync Storage Server. It is broadly described in \labelindexref{Subsection}{sub-sec:encrypting-and-decrypting-records}.

  \item \textbf{\textit{Meta}}. This collection includes a special record, called \textit{global}, which is not encrypted and contains general metadata to describe the state of the Sync Storage Server. This includes the global storage version and the set of available collections on the server \cite{sync-client-docs}.
\end{itemize}

\subsection{Encrypting and Decrypting Records}
\label{sub-sec:encrypting-and-decrypting-records}

Every collection on the Sync Storage Server has a key bundle associated formed of two keys: a symmetric encryption key and an HMAC key. The former is used to encrypt and decrypt the records with AES-256 (Advanced Encryption Standard), while the latter is used to verify the records with HMAC. Both keys are 32 bytes. The hashing algorithm used in HMAC is SHA-256. Besides the bundles associated with each collection, there is also a default key bundle which is supposed to be used when a collection does not have a key bundle associated.

All the key bundles (including the default one) are stored in the \textit{crypto/keys} record (i.e. the record with id \textit{keys} from the collection \textit{crypto}) on the Sync Storage Server. This is a normal record, but with a special meaning: being a record that holds information about the keys used to encrypt/decrypt all the other records, it cannot be encrypted with any of those keys for obvious reasons. Therefore it is encrypted and verified with a different key bundle, called the \textit{Sync Key Bundle}, which is derived from the \textit{Sync Key} introduced in \labelindexref{Section}{sec:firefox-accounts-server}.

Having the \textit{Sync Key}, deriving the \textit{Sync Key Bundle} is rather trivial: just perform a two-step HKDF with an all-zeros salt. The first iteration of HKDF outputs the AES encryption key and the second iteration outputs the HMAC key \cite{sync-client-docs}. Having the \textit{Sync Key Bundle}, the \textit{crypto/keys} record can be decrypted to extract the default key bundle together with the per-collection key bundles.

After that, the client is ready to upload and download records from the Sync Storage Server. The flow when uploading a record follows the next steps (the download flow is reversed):

\begin{enumerate}
  \item Serialize the object representing a bookmark/history/password/tab into a JSON object. The stringified JSON object represents the cleartext.

  \item Encrypt the cleartext with AES-256 using the encryption key from the corresponding collection's key bundle or the default key bundle if the collection does not have a key bundle associated. As an IV (Initialization Vector) for AES-256, the client uses a randomly generated 16-bytes token. AES-256 outputs the ciphertext which is Base64-encoded afterward.

  \item Compute the HMAC value of the Base64-encoded ciphertext using the HMAC key from the corresponding collection's key bundle or the default key bundle if the collection does not have a key bundle associated. The hashing algorithm used is SHA-256.

  \item Create a JSON object containing the Base64-encoded ciphertext, the Base64-encoded IV, and the hex encoded HMAC value. The stringified JSON object represents the payload of the BSO that is uploaded to the Sync Storage Server.

  \item Create a JSON object containing the id of the record and the previously computed payload. The id of the record is a Base64 URL-safe string that is randomly generated (however when updating a record the id must be preserved). The stringified JSON object represents the body of the request sent to the Sync Storage Server. This is the BSO that the server receives. Of course, the request is Hawk-authenticated with the Hawk id and key previously obtained from the Token Server.
\end{enumerate}
