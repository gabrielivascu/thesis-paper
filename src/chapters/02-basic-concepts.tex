\chapter{Basic Concepts}
\label{chapter:basic-concepts}

While the previous chapter offered a short introduction to data synchronization in web browsers and its importance, this chapter presents a more detailed description of how the synchronization is achieved. It covers aspects such as basic concepts and main challenges of synchronization, as well as a brief history of web browsers synchronization.

\section{Theoretical Background}
\label{sec:theoretical-background}

Many desktop and mobile web browsers nowadays offer users the possibility of having their data synchronized across all their connected devices. Regardless of how each web browser implements the synchronization, the end goal is the same: users being able to access their data on every device they run the web browser on. Moreover, the data needs to be correctly mirrored to every device.

\subsection{Synchronization Elements}
\label{sub-sec:sync-elements}

To achieve this kind of synchronization between instances of the same web browser, there are a few de facto concepts that most (if not all) implementations take into consideration. These are illustrated in \labelindexref{Figure}{img:web-browser-sync-overview} and described below:

\begin{itemize}
  \item \textbf{A storage server}. To be accessible to all the synchronization clients, the synchronized data needs to be stored in a common location available to be queried whenever needed. In some implementations, besides storing the synchronized records, the storage server may be responsible for sending push notifications to connected clients to notify them when data has been uploaded or modified on the server. This way the clients don't need to query the server themselves for changes. In the real world, there won't be only one storage server, but lots of them which form distributed data stores around the globe for reasons of good management and reliability. However, how the storage system is implemented is of no interest to the clients because they always see it as a single entity.

  \item \textbf{A communication protocol}. The synchronization clients need to be able to correctly communicate with the storage server to upload and download data. This is usually achieved through a specific API (Application Programming Interface) of the storage server that allows clients to add, delete or modify data. Moreover, the communication protocol usually plays an essential role in data security: the important data should not ever be transferred in clear text, but only encrypted.

  \item \textbf{An authentication method}. Web browsers need to be able to differentiate data from one user to another, meaning that one user should not end up with some data belonging to another user. That would be unfortunate and undesirable. To avoid these situations, web browsers enforce an authentication method based on some identity credentials (usually an username and a password). Most of the times, these are used to derive other authentication tokens that are passed to the storage server whenever synchronized records are uploaded or downloaded. In other situations, the credentials are used to obtain a particular storage server endpoint that only belongs to the concerned user.

  \item \textbf{A synchronization algorithm}. As mentioned in the previous chapter, the synchronization is a continuous process that requires planning and scheduling. Therefore, an algorithm capable of doing periodical synchronizations is required. To provide a good user experience, the synchronization needs to operate completely transparent and with minimal-to-zero user interaction. Most web browsers use a different thread than the UI (User Interface) thread to perform periodical synchronizations in the background and some of them also provide means to perform synchronizations at demand. Moreover, the synchronization algorithm should be able to ensure data consistency by carefully handling conflicts that may appear when data records are imported or exported to the storage server.
\end{itemize}

\fig[scale=0.8]{src/img/02WebBrowserSyncOverview.pdf}{img:web-browser-sync-overview}{Web Browser Synchronization Overview}

\clearpage

\subsection{Synchronization Challenges}
\label{sub-sec:sync-challenges}

Synchronization is not a trivial task, but a task that may grow a few challenges once you start implementing it. Most of these challenges come from:

\begin{itemize}
  \item \textbf{The complexity of the data format}. No matter what kind of data is being synchronized, all the source and destination systems need to be able to read that data correctly. Whether you do a synchronization over a wired or wireless network or a low-level synchronization over a communication bus, the data has to be reduced to raw bytes to be transferred from point A to point B. While most synchronizations already handle the data as raw bytes (e.g. file synchronization), there are cases when complex objects or data structures need to be synchronized. That means they have to be brought to a common format before being transmitted from source to destination and it falls into the responsibility of the communication protocol to stipulate what that common format is. This is the case of web browser synchronization too, where every item of browsing data which is synchronized (e.g. bookmarks, saved passwords, etc.) represents a different object with different properties. To solve this difficulty, the synchronized objects are serialized to a string representation of a format such as JSON (JavaScript Object Notation), XML (Extensible Markup Language), YAML (Yet Another Markup Language), MessagePack, etc. which is then sent "over the wire" as an array of bytes. When the other parties receive it, they will be able to reconstruct the object to its original form.

  \item \textbf{Ensuring data integrity}. A proper data synchronization mechanism should not be concerned with only sharing data between multiple endpoints, but also with the data being correct and consistent. A synchronization tool that may lose or corrupt some of the data from time to time is not something people will use. Ignoring the situations when data loss happens during transmission or due to a hardware failure, the most common causes of ending up with altered data are conflicts that appear when importing or exporting data to the storage server. More specifically, this happens when the same data has been modified both in the local storage and in the remote storage since the last synchronization. These situations have to be carefully handled by the synchronization algorithm which may choose whether to keep only the most recent modified version of the data or to merge both versions in the nicest way possible.

  \item \textbf{Ensuring data security}. The security of the data is another serious aspect of synchronization, especially when it comes to handling confidential or personal data. This is usually another thing that falls into the responsibility of the communication protocol since the data should be transferred in such a way that prevents attackers from being able to read the data. As a general rule, the sensitive data should always be transferred encrypted and not ever in clear text. In case the synchronization involves the existence of a centralized storage unit to keep the synchronized data, the data should also be stored encrypted there. Of course, this raises issues such as where are the encryption keys stored and who has access to them, but that is up to each implementation's design.

  \item \textbf{Providing real-timeliness}. Most synchronizations need to happen in real-time to provide a good user experience, i.e. a data modification, addition or deletion should be mirrored instantly to the other devices. Take the example of a software system that manages the selling and distribution of train tickets and is installed on all the devices from which tickets can be purchased at a train station. Whenever a user buys a ticket from one device and thus occupies a seat on the train, that seat will be immediately marked as taken on all the other devices in the train station. That means the software system is responsible for synchronizing the distribution of seats across all the ticket-selling devices in the train station in a real-time manner. To achieve a real-time synchronization, it is necessary to have a design based on push notifications. This means that whenever a client pushes a change to the central storage server, the server will notify with a message all the other clients about the change made. This implies that the server needs to maintain an active connection with all the clients to be able to exchange notification messages. Of course, real-time synchronization can be achieved without the existence of a central server too, but that will require significantly more effort since you'll have to maintain an N to N connection instead of an 1 to N connection. However, when it comes to synchronization in web browsers, it is not crucial to have the data synchronized instantaneously, but that would be a nice-to-have feature.

  \item \textbf{Providing a transparent synchronization}. As previously mentioned, most of the times, synchronization needs to take place in the background, without any user interaction. This implies protocols and algorithms carefully designed to be capable of performing synchronizations on their own, with no external help.
\end{itemize}

\section{Related Work}
\label{sec:related-work}

There is currently a variety of software products, open source or commercial, that offers users the possibility of synchronizing data (mostly files\footnote{\url{https://en.wikipedia.org/wiki/Comparison_of_file_synchronization_software}}) between computers. Most of them also act as a backup storage by storing the user data indefinitely. Common criteria for sorting file synchronization software range from portability and conflict detection to revision control and service scheduling.

On a more specific note, Maxthon\footnote{\url{http://www.maxthon.com/}} was the first browser to introduce bookmarks synchronization in 2005\footnote{\url{https://en.wikipedia.org/wiki/Comparison_of_browser_synchronizers}}. It was shortly followed by Mozilla's Firefox through the Google Browser Sync\footnote{\url{https://en.wikipedia.org/wiki/Google_Browser_Sync}} extension in 2006 and by Opera\footnote{\url{https://www.opera.com/}} in 2007. Shortly after, Mozilla developed its own synchronization technology, Firefox Sync, to replace the previous synchronization extension of Firefox. Since its inception in late 2008, Google Chrome\footnote{\url{https://www.google.com/chrome/}} had support for synchronization through the same technology of Google Browser Sync which was then integrated as a built-in feature.

Regardless of the web browser, the user experience with the synchronization is roughly the same. What is interesting is how the synchronization works behind the scenes.
